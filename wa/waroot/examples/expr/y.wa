// 版权 @2019 凹语言 作者。保留所有权利。

// Code generated by 'wa yacc yacc -l -p=expr -c=copyright.txt -o=y.wa expr.y'. DO NOT EDIT.

// 这是 凹语言 yacc 的例子, 用于对表达式进行解析, 为了简化词法部分暂时通过手工录入.

import "strconv" => __yystrconv__

type exprSymType :struct {
	yys: int
	num: int
}

const NUM = 57346

global exprToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"'+'",
	"'-'",
	"'*'",
	"'/'",
	"'('",
	"')'",
	"NUM",
}

global exprStatenames = [...]string{}

const exprEofCode = 1
const exprErrCode = 2
const exprInitialStackSize = 16

// Lex 结束标志
const eof = 0

type exprToken :struct {
	Kind:  int
	Value: int
}

type exprLexer :struct {
	tokens: []exprToken
	pos:    int
}

func exprLexer.Lex(yylval: *exprSymType) => int {
	if this.pos >= len(this.tokens) {
		return eof
	}
	tok := this.tokens[this.pos]
	this.pos++

	yylval.num = tok.Value
	return tok.Kind
}

func exprLexer.Error(s: string) {
	println("ERROR:", s)
}

func main {
	print("1+2*(3+4)-10 = ")
	exprParse(&exprLexer{
		tokens: []exprToken{
			{Kind: NUM, Value: 1},
			{Kind: '+'},
			{Kind: NUM, Value: 2},
			{Kind: '*'},
			{Kind: '('},
			{Kind: NUM, Value: 3},
			{Kind: '+'},
			{Kind: NUM, Value: 4},
			{Kind: ')'},
			{Kind: '-'},
			{Kind: NUM, Value: 10},
		},
	})
}

global exprExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const exprPrivate = 57344

const exprLast = 23

global exprAct = [...]int{
	7, 4, 5, 2, 21, 9, 6, 8, 12, 13,
	9, 1, 8, 16, 3, 19, 20, 17, 18, 14,
	15, 10, 11,
}

global exprPact = [...]int{
	-3, -1000, -1000, 17, -3, -3, 13, -1000, -1000, -3,
	2, 2, -1000, -1000, 2, 2, -5, 13, 13, -1000,
	-1000, -1000,
}

global exprPgo = [...]int{
	0, 3, 14, 6, 0, 11,
}

global exprR1 = [...]int{
	0, 5, 1, 1, 1, 2, 2, 2, 3, 3,
	3, 4, 4,
}

global exprR2 = [...]int{
	0, 1, 1, 2, 2, 1, 3, 3, 1, 3,
	3, 1, 3,
}

global exprChk = [...]int{
	-1000, -5, -1, -2, 4, 5, -3, -4, 10, 8,
	4, 5, -1, -1, 6, 7, -1, -3, -3, -4,
	-4, 9,
}

global exprDef = [...]int{
	0, -2, 1, 2, 0, 0, 5, 8, 11, 0,
	0, 0, 3, 4, 0, 0, 0, 6, 7, 9,
	10, 12,
}

global exprTok1 = [...]int{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	8, 9, 6, 4, 3, 5, 3, 7,
}

global exprTok2 = [...]int{
	2, 3, 10,
}

global exprTok3 = [...]int{
	0,
}

type exprErrorMessageInfo :struct {
	state: int
	token: int
	msg:   string
}

global exprErrorMessages = [...]exprErrorMessageInfo{}

/*	parser for yacc output	*/

global (
	exprDebug        = 0
	exprErrorVerbose = false
)

type exprParser :struct {
	lval:  exprSymType
	stack: [exprInitialStackSize]exprSymType
	char:  int
}

func exprParser.Lookahead => int {
	return this.char
}

func exprNewParser => *exprParser {
	return &exprParser{}
}

const exprFlag = -1000

func exprTokname(c: int) => string {
	if c >= 1 && c-1 < len(exprToknames) {
		if exprToknames[c-1] != "" {
			return exprToknames[c-1]
		}
	}
	return "tok-" + __yystrconv__.Itoa(c)
}

func exprStatname(s: int) => string {
	if s >= 0 && s < len(exprStatenames) {
		if exprStatenames[s] != "" {
			return exprStatenames[s]
		}
	}
	return "state-" + __yystrconv__.Itoa(s)
}

func exprErrorMessage(state, lookAhead: int) => string {
	const TOKSTART = 4

	if !exprErrorVerbose {
		return "syntax error"
	}

	for _, e := range exprErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + exprTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := exprPact[state]
	for tok := TOKSTART; tok-1 < len(exprToknames); tok++ {
		if n := base + tok; n >= 0 && n < exprLast && exprChk[exprAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if exprDef[state] == -2 {
		i := 0
		for exprExca[i] != -1 || exprExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; exprExca[i] >= 0; i += 2 {
			tok := exprExca[i]
			if tok < TOKSTART || exprExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if exprExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += exprTokname(tok)
	}
	return res
}

func exprlex1(lex: *exprLexer, lval: *exprSymType) => (char, token: int) {
	token = 0
	char = lex.Lex(lval)

out:
	for {
		if char <= 0 {
			token = exprTok1[0]
			break out
		}
		if char < len(exprTok1) {
			token = exprTok1[char]
			break out
		}
		if char >= exprPrivate {
			if char < exprPrivate+len(exprTok2) {
				token = exprTok2[char-exprPrivate]
				break out
			}
		}
		for i := 0; i < len(exprTok3); i += 2 {
			token = exprTok3[i+0]
			if token == char {
				token = exprTok3[i+1]
				break out
			}
		}
		break out
	}

	if token == 0 {
		token = exprTok2[1] /* unknown char */
	}
	if exprDebug >= 3 {
		println("lex " + exprTokname(token) + "(" + __yystrconv__.Itoa(char) + ")")
	}
	return char, token
}

func exprParse(exprlex: *exprLexer) => int {
	return exprNewParser().Parse(exprlex)
}

func exprParser.Parse(exprlex: *exprLexer) => int {
	exprn: int
	exprVAL: exprSymType
	exprDollar: []exprSymType
	_ = exprDollar // silence set and not used
	exprS := this.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	exprstate := 0
	this.char = -1
	exprtoken := -1 // this.char translated into internal numbering
	exprp := -1

	const __goto_exprstack = -1
	const __goto_exprnewstate = -2
	const __goto_exprdefault = -3
	__goto_x := __goto_exprstack

Loop:
	for {
		switch __goto_x {
		case __goto_exprstack:
			/* put a state and value onto the stack */
			if exprDebug >= 4 {
				println("char " + exprTokname(exprtoken) + " in " + exprStatname(exprstate))
			}

			exprp++
			if exprp >= len(exprS) {
				nyys := make([]exprSymType, len(exprS)*2)
				for i := 0; i < len(exprS); i++ {
					nyys[i] = exprS[i]
				}
				exprS = nyys
			}
			exprS[exprp] = exprVAL
			exprS[exprp].yys = exprstate

			__goto_x = __goto_exprnewstate
			continue Loop

		case __goto_exprnewstate:
			exprn = exprPact[exprstate]
			if exprn <= exprFlag {
				/* simple state */
				__goto_x = __goto_exprdefault
				continue Loop
			}
			if this.char < 0 {
				this.char, exprtoken = exprlex1(exprlex, &this.lval)
			}
			exprn += exprtoken
			if exprn < 0 || exprn >= exprLast {
				__goto_x = __goto_exprdefault
				continue Loop
			}
			exprn = exprAct[exprn]
			if exprChk[exprn] == exprtoken { /* valid shift */
				this.char = -1
				exprtoken = -1
				exprVAL = this.lval
				exprstate = exprn
				if Errflag > 0 {
					Errflag--
				}
				__goto_x = __goto_exprstack
				continue Loop
			}

			__goto_x = __goto_exprdefault
			continue Loop

		case __goto_exprdefault:
			/* default state action */
			exprn = exprDef[exprstate]
			if exprn == -2 {
				if this.char < 0 {
					this.char, exprtoken = exprlex1(exprlex, &this.lval)
				}

				/* look through exception table */
				xi := 0
				for {
					if exprExca[xi+0] == -1 && exprExca[xi+1] == exprstate {
						break
					}
					xi += 2
				}
				for xi += 2; ; xi += 2 {
					exprn = exprExca[xi+0]
					if exprn < 0 || exprn == exprtoken {
						break
					}
				}
				exprn = exprExca[xi+1]
				if exprn < 0 {
					// Make sure we report no lookahead when not parsing.
					exprstate = -1
					this.char = -1
					exprtoken = -1

					return 0
				}
			}
			if exprn == 0 {
				/* error ... attempt to resume parsing */
				switch Errflag {
				case 0, 1, 2: /* incompletely recovered error ... try again */
					if Errflag == 0 {
						exprlex.Error(exprErrorMessage(exprstate, exprtoken))
						Nerrs++
						if exprDebug >= 1 {
							println(exprStatname(exprstate) + " saw " + exprTokname(exprtoken))
						}
					}
					Errflag = 3

					/* find a state where "error" is a legal shift action */
					for exprp >= 0 {
						exprn = exprPact[exprS[exprp].yys] + exprErrCode
						if exprn >= 0 && exprn < exprLast {
							exprstate = exprAct[exprn] /* simulate a shift of "error" */
							if exprChk[exprstate] == exprErrCode {
								__goto_x = __goto_exprstack
								continue Loop
							}
						}

						/* the current p has no shift on "error", pop stack */
						if exprDebug >= 2 {
							println("error recovery pops state " + __yystrconv__.Itoa(exprS[exprp].yys))
						}
						exprp--
					}

					// Make sure we report no lookahead when not parsing.
					exprstate = -1
					this.char = -1
					exprtoken = -1

					/* there is no state on the stack with an error shift ... abort */
					return 1

				case 3: /* no shift yet; clobber input char */
					if exprDebug >= 2 {
						println("error recovery discards " + exprTokname(exprtoken))
					}
					if exprtoken == exprEofCode {
						// Make sure we report no lookahead when not parsing.
						exprstate = -1
						this.char = -1
						exprtoken = -1

						return 1
					}
					this.char = -1
					exprtoken = -1

					__goto_x = __goto_exprnewstate /* try again in the same state */
					continue Loop
				}
			}

			/* reduction by production exprn */
			if exprDebug >= 2 {
				println("reduce " + __yystrconv__.Itoa(exprn) + " in:")
				println("\t" + exprStatname(exprstate))
			}

			exprnt := exprn
			exprpt := exprp
			_ = exprpt // guard against "declared and not used"

			exprp -= exprR2[exprn]
			// exprp is now the index of $0. Perform the default action. Iff the
			// reduced production is ε, $1 is possibly out of range.
			if exprp+1 >= len(exprS) {
				nyys := make([]exprSymType, len(exprS)*2)
				for i := 0; i < len(exprS); i++ {
					nyys[i] = exprS[i]
				}
				exprS = nyys
			}
			exprVAL = exprS[exprp+1]

			/* consult goto table to find next state */
			exprn = exprR1[exprn]
			exprg := exprPgo[exprn]
			exprj := exprg + exprS[exprp].yys + 1

			if exprj >= exprLast {
				exprstate = exprAct[exprg]
			} else {
				exprstate = exprAct[exprj]
				if exprChk[exprstate] != -exprn {
					exprstate = exprAct[exprg]
				}
			}
			// dummy call; replaced with literal code
			switch exprnt {

			case 1:
				exprDollar = exprS[exprpt-1 : exprpt+1]
				{
					println(exprDollar[1].num)
				}
			case 3:
				exprDollar = exprS[exprpt-2 : exprpt+1]
				{
					exprVAL.num = exprDollar[2].num
				}
			case 4:
				exprDollar = exprS[exprpt-2 : exprpt+1]
				{
					exprVAL.num = -exprDollar[2].num
				}
			case 6:
				exprDollar = exprS[exprpt-3 : exprpt+1]
				{
					exprVAL.num = exprDollar[1].num + exprDollar[3].num
				}
			case 7:
				exprDollar = exprS[exprpt-3 : exprpt+1]
				{
					exprVAL.num = exprDollar[1].num - exprDollar[3].num
				}
			case 9:
				exprDollar = exprS[exprpt-3 : exprpt+1]
				{
					exprVAL.num = exprDollar[1].num * exprDollar[3].num
				}
			case 10:
				exprDollar = exprS[exprpt-3 : exprpt+1]
				{
					exprVAL.num = exprDollar[1].num / exprDollar[3].num
				}
			case 12:
				exprDollar = exprS[exprpt-3 : exprpt+1]
				{
					exprVAL.num = exprDollar[2].num
				}
			}

			__goto_x = __goto_exprstack /* stack new state and value */
			continue Loop

		} // switch
	} // for
}
